import { NextResponse } from "next/server";
import { z } from "zod";
// import { verifyRecaptcha } from "@/lib/recaptcha"; // ‚ùå TEMPORAIREMENT D√âSACTIV√â
import { writeFile, mkdir } from "fs/promises";
import { join } from "path";
import nodemailer from "nodemailer";
import { existsSync } from "fs";

// Sch√©ma de validation des donn√©es
const candidatureSchema = z.object({
  name: z
    .string()
    .min(2)
    .max(100)
    .regex(/^[a-zA-Z√Ä-√ø\s-]+$/),
  email: z.string().email().max(254),
  phone: z
    .string()
    .refine(
      (val) =>
        !val ||
        /^[+]?[(]?[0-9]{3}[)]?[-\s.]?[0-9]{3}[-\s.]?[0-9]{4,6}$/.test(val)
    )
    .optional(),
  message: z.string().min(10).max(1000),
  csrfToken: z.string(),
  recaptchaToken: z.string(), // On garde le champ mais on ne le valide pas
});

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ALLOWED_FILE_TYPES = [
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
];

export async function POST(request: Request) {
  console.log("=== CANDIDATURE API START ===");

  try {
    // 1. V√©rifier les headers
    console.log(
      "Headers re√ßus:",
      Object.fromEntries(request.headers.entries())
    );

    // 2. Lire le FormData
    console.log("Lecture du FormData...");
    let formData: FormData;
    try {
      formData = await request.formData();
      console.log("FormData lu avec succ√®s");

      // Lister tous les champs (sans iterator)
      console.log("Champs FormData:");
      const fields = [
        "name",
        "email",
        "phone",
        "message",
        "csrfToken",
        "recaptchaToken",
        "cv",
        "lettre",
      ];
      fields.forEach((key) => {
        const value = formData.get(key);
        if (value instanceof File) {
          console.log(
            `  ${key}: File(${value.name}, ${value.size} bytes, ${value.type})`
          );
        } else if (value) {
          console.log(`  ${key}: ${value}`);
        } else {
          console.log(`  ${key}: null/undefined`);
        }
      });
    } catch (error) {
      console.error("Erreur lecture FormData:", error);
      return NextResponse.json(
        { error: "Erreur lecture FormData" },
        { status: 400 }
      );
    }

    // 3. V√©rifier le token CSRF
    console.log("V√©rification CSRF...");
    const csrfToken = request.headers.get("X-CSRF-Token");
    const formCsrfToken = formData.get("csrfToken");
    console.log("CSRF header:", csrfToken);
    console.log("CSRF form:", formCsrfToken);

    if (!csrfToken || csrfToken !== formCsrfToken) {
      console.error("Token CSRF invalide");
      return NextResponse.json(
        { error: "Token CSRF invalide" },
        { status: 403 }
      );
    }

    // 4. TEMPORAIREMENT : Skip la v√©rification reCAPTCHA
    console.log("‚ö†Ô∏è SKIP v√©rification reCAPTCHA (mode test)");
    /*
    console.log("V√©rification reCAPTCHA...");
    const recaptchaToken = request.headers.get("X-Recaptcha-Token");
    if (!recaptchaToken) {
      console.error("Token reCAPTCHA manquant");
      return NextResponse.json(
        { error: "Token reCAPTCHA manquant" },
        { status: 400 }
      );
    }

    console.log("Appel verifyRecaptcha...");
    const recaptchaResult = await verifyRecaptcha(recaptchaToken);
    if (!recaptchaResult.success) {
      console.error("V√©rification reCAPTCHA √©chou√©e:", recaptchaResult);
      return NextResponse.json(
        { error: "V√©rification reCAPTCHA √©chou√©e" },
        { status: 400 }
      );
    }
    console.log("reCAPTCHA valid√©");
    */

    // 5. Valider les donn√©es du formulaire
    console.log("Validation des donn√©es...");
    let validatedData;
    try {
      validatedData = candidatureSchema.parse({
        name: formData.get("name"),
        email: formData.get("email"),
        phone: formData.get("phone") || "",
        message: formData.get("message"),
        csrfToken: formData.get("csrfToken"),
        recaptchaToken: formData.get("recaptchaToken"), // On accepte "test-token"
      });
      console.log("Donn√©es valid√©es:", {
        name: validatedData.name,
        email: validatedData.email,
        hasPhone: !!validatedData.phone,
        messageLength: validatedData.message.length,
      });
    } catch (error) {
      console.error("Erreur validation Zod:", error);
      return NextResponse.json(
        { error: "Donn√©es invalides", details: error },
        { status: 400 }
      );
    }

    // 6. V√©rifier les fichiers
    console.log("V√©rification des fichiers...");
    const cv = formData.get("cv") as File;
    const lettre = formData.get("lettre") as File;

    console.log(
      "CV:",
      cv ? `${cv.name} (${cv.size} bytes, ${cv.type})` : "absent"
    );
    console.log(
      "Lettre:",
      lettre
        ? `${lettre.name} (${lettre.size} bytes, ${lettre.type})`
        : "absent"
    );

    if (!cv || !lettre) {
      console.error("Fichiers manquants");
      return NextResponse.json(
        { error: "CV et lettre de motivation requis" },
        { status: 400 }
      );
    }

    // 7. V√©rifier la taille des fichiers
    if (cv.size > MAX_FILE_SIZE || lettre.size > MAX_FILE_SIZE) {
      console.error("Fichiers trop gros:", {
        cvSize: cv.size,
        lettreSize: lettre.size,
      });
      return NextResponse.json(
        { error: "Les fichiers ne doivent pas d√©passer 5MB" },
        { status: 400 }
      );
    }

    // 8. V√©rifier le type des fichiers
    if (
      !ALLOWED_FILE_TYPES.includes(cv.type) ||
      !ALLOWED_FILE_TYPES.includes(lettre.type)
    ) {
      console.error("Types de fichiers non autoris√©s:", {
        cvType: cv.type,
        lettreType: lettre.type,
      });
      return NextResponse.json(
        { error: "Format de fichier non autoris√©" },
        { status: 400 }
      );
    }

    // 9. Cr√©er le dossier uploads s'il n'existe pas
    console.log("V√©rification du dossier uploads...");
    const uploadDir = join(process.cwd(), "uploads");
    console.log("Chemin uploads:", uploadDir);

    if (!existsSync(uploadDir)) {
      console.log("Dossier uploads n'existe pas, cr√©ation...");
      try {
        await mkdir(uploadDir, { recursive: true });
        console.log("Dossier uploads cr√©√©");
      } catch (error) {
        console.error("Erreur cr√©ation dossier uploads:", error);
        return NextResponse.json(
          { error: "Erreur cr√©ation dossier uploads" },
          { status: 500 }
        );
      }
    } else {
      console.log("Dossier uploads existe d√©j√†");
    }

    // 10. G√©n√©rer des noms de fichiers uniques
    const timestamp = Date.now();
    const sanitizedName = validatedData.name
      .toLowerCase()
      .replace(/\s+/g, "-")
      .replace(/[^a-z0-9-]/g, "");
    const cvFileName = `${sanitizedName}-cv-${timestamp}.${
      cv.type.split("/")[1]
    }`;
    const lettreFileName = `${sanitizedName}-lettre-${timestamp}.${
      lettre.type.split("/")[1]
    }`;

    console.log("Noms de fichiers:", { cvFileName, lettreFileName });

    // 11. Sauvegarder les fichiers
    console.log("Sauvegarde des fichiers...");
    try {
      const cvBuffer = Buffer.from(await cv.arrayBuffer());
      const lettreBuffer = Buffer.from(await lettre.arrayBuffer());

      await writeFile(join(uploadDir, cvFileName), cvBuffer);
      console.log("CV sauvegard√©");

      await writeFile(join(uploadDir, lettreFileName), lettreBuffer);
      console.log("Lettre sauvegard√©e");
    } catch (error) {
      console.error("Erreur sauvegarde fichiers:", error);
      return NextResponse.json(
        { error: "Erreur sauvegarde fichiers" },
        { status: 500 }
      );
    }

    // 12. Configuration email
    console.log("Configuration de l'email...");
    const emailUser = process.env.EMAIL_USER;
    const emailPassword = process.env.EMAIL_PASSWORD;

    if (!emailUser || !emailPassword) {
      console.error("Variables d'environnement email manquantes");
      return NextResponse.json(
        { error: "Configuration email manquante" },
        { status: 500 }
      );
    }

    // 13. Cr√©er le transporteur
    console.log("Cr√©ation du transporteur email...");
    let transporter;
    try {
      transporter = nodemailer.createTransport({
        host: "node101-eu.n0c.com",
        port: 587,
        secure: false,
        auth: {
          user: emailUser,
          pass: emailPassword,
        },
        tls: {
          ciphers: "SSLv3",
          rejectUnauthorized: false,
        },
      });
      console.log("Transporteur cr√©√©");
    } catch (error) {
      console.error("Erreur cr√©ation transporteur:", error);
      return NextResponse.json(
        { error: "Erreur configuration email" },
        { status: 500 }
      );
    }

    // 14. Convertir fichiers en attachements
    console.log("Pr√©paration des pi√®ces jointes...");
    const cvBuffer = Buffer.from(await cv.arrayBuffer());
    const lettreBuffer = Buffer.from(await lettre.arrayBuffer());

    // 15. Pr√©parer l'email
    const mailOptions = {
      from: emailUser,
      to: emailUser,
      subject: `üöÄ Application Viene Form ${validatedData.name}`,
      html: `
        <h2 style="color: #2563eb;">üöÄ Nouvelle candidature re√ßue</h2>
        <div style="background: #f8fafc; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <p><strong>üë§ Nom :</strong> ${validatedData.name}</p>
          <p><strong>üìß Email :</strong> ${validatedData.email}</p>
          ${
            validatedData.phone
              ? `<p><strong>üìû T√©l√©phone :</strong> ${validatedData.phone}</p>`
              : ""
          }
          <p><strong>üí¨ Message :</strong></p>
          <div style="background: white; padding: 15px; border-radius: 4px; border-left: 4px solid #2563eb;">
            ${validatedData.message.replace(/\n/g, "<br>")}
          </div>
        </div>
        <p><em>üìé Les fichiers CV et lettre de motivation sont en pi√®ces jointes.</em></p>
        <hr style="margin: 20px 0;">
        <p style="color: #6b7280; font-size: 14px;">
          üìÖ Candidature re√ßue le ${new Date().toLocaleDateString("fr-FR", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
          })}
        </p>
      `,
      attachments: [
        {
          filename: cv.name,
          content: cvBuffer,
          contentType: cv.type,
        },
        {
          filename: lettre.name,
          content: lettreBuffer,
          contentType: lettre.type,
        },
      ],
    };

    // 16. Envoyer l'email
    console.log("Envoi de l'email...");
    try {
      const info = await transporter.sendMail(mailOptions);
      console.log("Email envoy√© avec succ√®s:", info.messageId);
    } catch (error) {
      console.error("Erreur envoi email:", error);
      return NextResponse.json(
        { error: "Erreur lors de l'envoi de l'email" },
        { status: 500 }
      );
    }

    // 17. Logger la soumission (remplac√© par console.log)
    console.log("Logging de la soumission...");
    console.log("Nouvelle candidature re√ßue:", {
      name: validatedData.name,
      email: validatedData.email,
      ip: request.headers.get("x-forwarded-for") || "unknown",
      userAgent: request.headers.get("user-agent") || "unknown",
      files: {
        cv: cvFileName,
        lettre: lettreFileName,
      },
    });

    console.log("=== CANDIDATURE API SUCCESS ===");
    return NextResponse.json(
      { message: "Candidature envoy√©e avec succ√®s" },
      { status: 200 }
    );
  } catch (error) {
    console.error("=== CANDIDATURE API ERROR ===");
    console.error("Erreur g√©n√©rale:", error);
    console.error("Stack:", error instanceof Error ? error.stack : "No stack");

    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Donn√©es invalides", details: error.errors },
        { status: 400 }
      );
    }

    // Logger l'erreur (remplac√© par console.log)
    console.error("Erreur lors du traitement de la candidature:", {
      error: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : undefined,
    });

    return NextResponse.json(
      { error: "Une erreur est survenue" },
      { status: 500 }
    );
  }
}
